package mdmnw.externalrule;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Vector;

import mdmnw.component.XNWAddressBObjExt;
import mdmnw.component.XNWPartyAddressBObjExt;
import mdmnw.component.XNWPersonBObjExt;
import mdmnw.component.XNWPersonNameBObjExt;
import mdmnw.constant.MdmConstants;
import mdmnw.utils.CommonUtil;

import com.dwl.base.DWLControl;
import com.dwl.base.DWLResponse;
import com.dwl.base.IDWLErrorMessage;
import com.dwl.base.error.DWLError;
import com.dwl.base.error.DWLStatus;
import com.dwl.base.exception.DWLBaseException;
import com.dwl.base.exception.DWLPropertyNotFoundException;
import com.dwl.base.externalrule.Rule;
import com.dwl.base.logging.DWLLoggerManager;
import com.dwl.base.logging.IDWLLogger;
import com.dwl.base.util.StringUtils;
import com.dwl.management.ManagementException;
import com.dwl.management.config.client.Configuration;
import com.dwl.management.config.repository.ConfigurationRepositoryException;
import com.dwl.tcrm.common.TCRMCommon;
import com.dwl.tcrm.common.TCRMErrorCode;
import com.dwl.tcrm.coreParty.component.TCRMAdminContEquivBObj;
import com.dwl.tcrm.coreParty.component.TCRMPartyBObj;
import com.dwl.tcrm.coreParty.component.TCRMPartyContactMethodBObj;
import com.dwl.tcrm.coreParty.component.TCRMPartyIdentificationBObj;
import com.dwl.tcrm.coreParty.component.TCRMPartyValueBObj;
import com.dwl.tcrm.coreParty.component.TCRMPartyComponent;
import com.dwl.tcrm.coreParty.component.TCRMPersonBObj;
import com.dwl.tcrm.coreParty.component.TCRMSuspectPersonBObj;
import com.dwl.tcrm.coreParty.constant.TCRMCoreComponentID;
import com.dwl.tcrm.coreParty.constant.TCRMCoreErrorReasonCode;
import com.dwl.tcrm.coreParty.constant.TCRMCorePropertyKeys;
import com.dwl.tcrm.coreParty.interfaces.IParty;
import com.dwl.tcrm.utilities.TCRMClassFactory;
import com.dwl.unifi.tx.exception.BusinessProxyException;

/**
 * CollapsePartiesWithRules collapses party1 and party2 parties to create new party.
 * Unique data in party1 and party2 are survived in new party.
 * In case of duplicate data the one with the preferred source will survive.
 * If they are from the same source, the one with the most recent last update date will survive.
 * Usage Type or Usage Type+Value are used to identify duplicates
 *
 * 
 */
public class CollapsePartiesWithRules extends Rule {

	protected final static IDWLLogger logger = DWLLoggerManager.getLogger(CollapsePartiesWithRules.class);

	protected String ruleName = "CollapsePartiesWithRules";
	protected String debugStr = "External Java Rule 38 " + ruleName + ": ";
	private ArrayList<String> multiValueNames;
//	private String updateFlag = "";
	private TCRMPartyBObj objParty1BObj = null;
	private TCRMPartyBObj objParty2BObj = null;

	/**
	 * This is the main method in CollapsePartiesWithRules retrieves Party 1 and 
	 * party 2 from input invokes individual business object collapse method to
	 * collapse data, create new party with survived data from party1 and party2 and return new party.
	 * 
	 * @param input
	 * @param componentObject
	 * @return vector newPartyBobj 
	 * @throws Exception	 
	 */
	@SuppressWarnings({ "rawtypes", "unchecked" })
	public Object execute(Object input, Object componentObject)
			throws Exception {			
		IParty partyComp = (IParty) TCRMClassFactory
				.getTCRMComponent(TCRMCorePropertyKeys.PARTY_COMPONENT);
		// Get the involved parties as a vector of objects
		Vector vecParties = (Vector) input;

		// Set up variables that will be needed later
		DWLStatus status = new DWLStatus();
		status.setStatus(DWLStatus.SUCCESS);
		Vector vecRet = new Vector();
		//		TCRMPartyBObj newPartyBobj = null;
		DWLControl objDWLControl = null;

		try {
			logger.info("Inside NW CollapsePartiesWithRules");	           

			// get the party objects from the vector
			objParty1BObj = (TCRMPartyBObj) vecParties.elementAt(0);
			objParty2BObj = (TCRMPartyBObj) vecParties.elementAt(1);

//			if(vecParties.size()>2)
//				updateFlag = (String) vecParties.elementAt(2);

			// if the second object is a TCRMSuspectPersonBObj object, get the XNWPersonBObjExt version of the object by calling out to MDM
			if(objParty2BObj instanceof TCRMSuspectPersonBObj){
				// set get person params to get existing person object
				Vector<String> params = new Vector<String>();
				params.add(objParty2BObj.getPartyId());
				params.add(MdmConstants.INQRY_LVL_4);
				CommonUtil util = new CommonUtil();

				// execute get person transaction
				DWLResponse response = util.invokeBaseInquiryTxn(MdmConstants.TXN_GETPERSON, params, objParty2BObj.getControl());

				// get person as XNWPersonBObjExt object and set last update dates in order to be able to update the object
				objParty2BObj = (XNWPersonBObjExt)response.getData();
			}

			objDWLControl = objParty1BObj.getControl();

			// set the survivorship configs if they haven't been already
			if(objDWLControl.get("SurvivorshipRulesSet") == null || objDWLControl.get("SurvivorshipRulesSet").equals("false")){
				setSurvivorshipConfigs(objDWLControl);
			}

			//			newPartyBobj = new XNWPersonBObjExt();
			//			newPartyBobj = objParty1BObj;

			// specify which name usage types are muilti-valued
			multiValueNames = new ArrayList<String>();
			multiValueNames.add("Also Known As");

			// get the party identification objects from the parties and collapse them
			Vector <TCRMPartyIdentificationBObj> vecParty1Identification =  objParty1BObj.getItemsTCRMPartyIdentificationBObj();
			Vector <TCRMPartyIdentificationBObj> vecParty2Identification =  objParty2BObj.getItemsTCRMPartyIdentificationBObj();			  
			mergePartyIdentificationBObj(false, vecParty1Identification, vecParty2Identification, objParty1BObj, (ArrayList<String>)objDWLControl.get("Survivorship/TCRMPartyIdentificationBObj/"));

			// get the party value objects from the parties and collapse them
			Vector <TCRMPartyValueBObj> vecParty1Value =  objParty1BObj.getItemsTCRMPartyValueBObj();
			Vector <TCRMPartyValueBObj> vecParty2Value =  objParty2BObj.getItemsTCRMPartyValueBObj();			  
			mergePartyValueBObj(false, vecParty1Value, vecParty2Value, objParty1BObj, (ArrayList<String>)objDWLControl.get("Survivorship/TCRMPartyValueBObj/"));

			// get the party address objects from the parties and collapse them
			Vector <XNWPartyAddressBObjExt> vecParty1Addr = objParty1BObj.getItemsTCRMPartyAddressBObj();
			Vector <XNWPartyAddressBObjExt> vecParty2Addr = objParty2BObj.getItemsTCRMPartyAddressBObj();			  
			mergePartyAddressBObj(false, vecParty1Addr, vecParty2Addr, objParty1BObj, (ArrayList<String>)objDWLControl.get("Survivorship/XNWPartyAddressBObjExt/"));

			// get the party contact method objects from the parties and collapse them
			Vector <TCRMPartyContactMethodBObj> vecParty1ContMeth = objParty1BObj.getItemsTCRMPartyContactMethodBObj();
			Vector <TCRMPartyContactMethodBObj> vecParty2ContMeth = objParty2BObj.getItemsTCRMPartyContactMethodBObj();			  
			mergePartyContactMethodBObj(false, vecParty1ContMeth, vecParty2ContMeth, objParty1BObj, (ArrayList<String>)objDWLControl.get("Survivorship/TCRMPartyContactMethodBObj/"));

			// get the party admin key objects from the parties and collapse them
			Vector <TCRMAdminContEquivBObj> vecParty1AdminContEquiv = new Vector <TCRMAdminContEquivBObj>();
			if(objParty1BObj.getPartyId() != null){
				vecParty1AdminContEquiv = ((IParty) partyComp).getAllPartyAdminSysKeys(objParty1BObj.getPartyId(), objDWLControl);																							    			  
			}
			else{
				vecParty1AdminContEquiv = objParty1BObj.getItemsTCRMAdminContEquivBObj();
			}

			Vector <TCRMAdminContEquivBObj> vecParty2AdminContEquiv = new Vector <TCRMAdminContEquivBObj>();
			if(objParty2BObj.getPartyId() != null){
				vecParty2AdminContEquiv = ((IParty) partyComp).getAllPartyAdminSysKeys(objParty2BObj.getPartyId(), objDWLControl);																								    			  
			}
			else{
				vecParty2AdminContEquiv = objParty2BObj.getItemsTCRMAdminContEquivBObj();		
			}
			mergeAdminContEquivBObj(vecParty1AdminContEquiv, vecParty2AdminContEquiv, objParty1BObj);				

			if(objParty1BObj instanceof XNWPersonBObjExt)
			{
				// get the person objects from the parties and collapse them
				XNWPersonBObjExt objPerson1BObj = (XNWPersonBObjExt)objParty1BObj;
				XNWPersonBObjExt objPerson2BObj = (XNWPersonBObjExt)objParty2BObj;
				mergePersonBObj((XNWPersonBObjExt)objParty1BObj, (XNWPersonBObjExt)objParty2BObj, (XNWPersonBObjExt)objParty1BObj, (ArrayList<String>)objDWLControl.get("Survivorship/TCRMPersonBObj/"));

				// get the person name objects from the parties and collapse them
				Vector <XNWPersonNameBObjExt> vecPerson1Name = objPerson1BObj.getItemsTCRMPersonNameBObj();			  
				Vector <XNWPersonNameBObjExt> vecPerson2Name = objPerson2BObj.getItemsTCRMPersonNameBObj();
				mergePersonNameBObj(false, vecPerson1Name,vecPerson2Name, (XNWPersonBObjExt)objParty1BObj, (ArrayList<String>)objDWLControl.get("Survivorship/TCRMPersonNameBObj/"));
			}

		} catch (DWLBaseException ex) {	            
			logger.error("DWLBaseException in execute method of CollapsePartiesWithRules == "+ex.toString());
			com.dwl.base.util.DWLExceptionUtils.log(ex);
			status = ex.getStatus();
		} catch (Exception ex) {
			logger.error("Exception in execute method of CollapsePartiesWithRules == "+ex.toString());	            
			com.dwl.base.util.DWLExceptionUtils.log(ex);
			status = addError(
					objDWLControl,
					TCRMErrorCode.READ_RECORD_ERROR,
					TCRMCoreErrorReasonCode.COLLAPSE_PARTIES_SURVIVING_RULES_FAILED,
					ex.getMessage());
		}

//		if(updateFlag.equalsIgnoreCase("true")){
//			objParty1BObj.setPartyId(objParty2BObj.getPartyId());
//		} else{
			objParty1BObj.setPartyId(null);
//		}

		vecRet.addElement(status);
		vecRet.addElement(objParty1BObj);

		return vecRet;
	}

	/**
	 * This method collapses Party 1 and Party 2 PartyIdentification business objects.
	 * Survive all Identification Object
	 * @param rules 
	 * 
	 * @param vector sourcePartyIdentificationBObj
	 * @param vector targetPartyIdentificationBObj
	 * @param newOrgBobj
	 * @return  
	 * @throws Exception	 
	 *  
	 */			  
	public void mergePartyIdentificationBObj(boolean externallyCalled, Vector <TCRMPartyIdentificationBObj> vecParty1Vals, Vector <TCRMPartyIdentificationBObj> vecParty2Vals, TCRMPartyBObj newPartyBobj, ArrayList<String> rules) throws Exception
	{			 
		String srcField;
		String usageType;
		String lastUpdField;
		String srcPriorityOrder;
//		Vector<TCRMCommon> loserPartyVals = new Vector<TCRMCommon>();
//		Vector<TCRMPartyIdentificationBObj> losersCasted = new Vector<TCRMPartyIdentificationBObj>();
		String fieldsAffected;
		
		// parse the rule entries and store into a party rule ArrayList
		if(rules != null && rules.size() > 0){
			ArrayList<String[]> parsedRules = new ArrayList<String[]>();
			for (String rule : rules) {
				String[] partyRuleArr = rule.split("\\|");

				if(partyRuleArr.length != 5){
					throw new BusinessProxyException("In record collapse. Survivorship rule requires 5 settings. Found: " + partyRuleArr.length);
				} else{
					parsedRules.add(partyRuleArr);
				}
			}

			// compare rows from each party to each other using the rules in the party rules array
			for (TCRMPartyIdentificationBObj party1Value : vecParty1Vals) {
				for (TCRMPartyIdentificationBObj party2Value : vecParty2Vals) {

					for (String[] ruleArr : parsedRules) {

						// store rules in variables
						srcField = ruleArr[0];
						usageType = ruleArr[1];
						lastUpdField = ruleArr[2];
						srcPriorityOrder = ruleArr[3];
						fieldsAffected = ruleArr[4];
						
						// uniqueness is based on usage type only
						if(party1Value.getIdentificationValue().equals(party2Value.getIdentificationValue())
								&& party1Value.getIdentificationValue().equals(usageType)){
							// the call below returns the *non-survivors*
							applySurvivorship(srcField, lastUpdField, srcPriorityOrder, fieldsAffected, party1Value, party2Value, newPartyBobj);
						}
					}
				}
			}

//			// if called from within this class (execute method) combine all the attributes into the primary vector
//			if(!externallyCalled)
//				vecParty1Vals.addAll(vecParty2Vals);
//
//			// cast the loser objects to as TCRMPartyIdentificationBObj objects
//			for (TCRMCommon loserPartyVal : loserPartyVals){
//				losersCasted.add((TCRMPartyIdentificationBObj)loserPartyVal);
//			}
//
//			// remove all loser objects from the primary vector. This leaves the survivors in the primary vector
//			vecParty1Vals.removeAll(losersCasted);
		}

		// if called from within this class (execute method), go thorugh each row in the 
		// primary vector and set the last upd and idpk to null
		if(!externallyCalled){
			for(int x=0; x< vecParty1Vals.size(); x++)
			{
				TCRMPartyIdentificationBObj mergedBobj = (TCRMPartyIdentificationBObj) vecParty1Vals.get(x);

//				if(updateFlag.equalsIgnoreCase("true")){
//					mergedBobj.setPartyId(objParty2BObj.getPartyId());
//				}
//				else{
					mergedBobj.setPartyId(null);
					mergedBobj.setPartyIdentificationLastUpdateDate(null);
					mergedBobj.setIdentificationIdPK(null);			
//				}
				
//				if(!newPartyBobj.getItemsTCRMPartyIdentificationBObj().contains(mergedBobj)){
//					newPartyBobj.getItemsTCRMPartyIdentificationBObj().add(mergedBobj);
//				}
			}
		}

		// clear the existing attribute objects from the party and add the primary vector objects to the party
		//		newPartyBobj.getItemsTCRMPartyIdentificationBObj().clear();
		//		newPartyBobj.getItemsTCRMPartyIdentificationBObj().addAll(vecParty1Vals);

		// in case where the method is called from outside this class (MaintainNWPersonCompositeTxnBP.java for example), return the *non-surviving* objects)
//		return losersCasted; 	
	}

	public void mergePartyValueBObj(boolean externallyCalled, Vector<TCRMPartyValueBObj> vecParty1Vals, Vector<TCRMPartyValueBObj> vecParty2Vals, TCRMPartyBObj newPartyBobj, ArrayList<String> rules) throws Exception
	{			 
		String srcField;
		String usageType;
		String lastUpdField;
		String srcPriorityOrder;
		String fieldsAffected;
		Vector<TCRMCommon> loserPartyVals = new Vector<TCRMCommon>();
		Vector<TCRMPartyValueBObj> losersCasted = new Vector<TCRMPartyValueBObj>();

		// parse the rule entries and store into a party rule ArrayList
		if(rules != null && rules.size() > 0){
			ArrayList<String[]> parsedRules = new ArrayList<String[]>();
			for (String rule : rules) {
				String[] partyRuleArr = rule.split("\\|");

				if(partyRuleArr.length != 5){
					throw new BusinessProxyException("In record collapse. Survivorship rule requires 5 settings. Found: " + partyRuleArr.length);
				} else{
					parsedRules.add(partyRuleArr);
				}
			}

			// compare rows from each party to each other using the rules in the party rules array
			for (TCRMPartyValueBObj party1Value : vecParty1Vals) {
				for (TCRMPartyValueBObj party2Value : vecParty2Vals) {

					for (String[] ruleArr : parsedRules) {

						// store rules in variables
						srcField = ruleArr[0];
						usageType = ruleArr[1];
						lastUpdField = ruleArr[2];
						srcPriorityOrder = ruleArr[3];
						fieldsAffected = ruleArr[4];
						
						// uniqueness is based on usage type and value combination
						if(party1Value.getPartyValueValue().equals(party2Value.getPartyValueValue())
								&& party1Value.getPartyValueValue().equals(usageType)
								&& StringUtils.compareWithTrim(party1Value.getValueString(), party2Value.getValueString())){
							// the call below returns the *non-survivors*
							applySurvivorship(srcField, lastUpdField, srcPriorityOrder, fieldsAffected, party1Value, party2Value, newPartyBobj);

						}
					}
				}
			}

//			// if called from within this class (execute method) combine all the attributes into the primary vector
//			if(!externallyCalled)
//				vecParty1Vals.addAll(vecParty2Vals);
//
//			// cast the loser objects to as appropriate object type
//			for (TCRMCommon loserPartyVal : loserPartyVals){
//				losersCasted.add((TCRMPartyValueBObj)loserPartyVal);
//			}
//
//			// remove all loser objects from the primary vector. This leaves the survivors in the primary vector
//			vecParty1Vals.removeAll(losersCasted);
//
		}

		// if called from within this class (execute method), go thorugh each row in the 
		// primary vector and set the last upd and idpk to null
		if(!externallyCalled){
			for(int x=0; x< vecParty1Vals.size(); x++)
			{
				TCRMPartyValueBObj mergedBobj = (TCRMPartyValueBObj) vecParty1Vals.get(x);
//				if(updateFlag.equalsIgnoreCase("true")){
//					mergedBobj.setPartyId(objParty2BObj.getPartyId());
//				}
//				else{
					mergedBobj.setPartyId(null);
					mergedBobj.setPartyValueLastUpdateDate(null);
					mergedBobj.setPartyValueId(null);			
//				}

//				if(!newPartyBobj.getItemsTCRMPartyValueBObj().contains(mergedBobj)){
//					newPartyBobj.getItemsTCRMPartyValueBObj().add(mergedBobj);
//				}
			}
		}

		// clear the existing attribute objects from the party and add the primary vector objects to the party
		//		newPartyBobj.getItemsTCRMPartyValueBObj().clear();
		//		newPartyBobj.getItemsTCRMPartyValueBObj().addAll(vecParty1Vals);

		// in case where the method is called from outside this class (MaintainNWPersonCompositeTxnBP.java for example), return the *non-surviving* objects)
//		return losersCasted;
	}

	/*
	 * Finds the non-surviving objects when comparing objects
	 */
	private void applySurvivorship(String srcField, String lastUpdField, String srcPriorityOrder, String fieldsAffected, TCRMCommon party1Value, TCRMCommon party2Value, TCRMPartyBObj newPartyBobj) throws ParseException {

		Vector<TCRMCommon> loserPartyVals = new Vector<TCRMCommon>();

		// get the sources from the objects
		String party1ValSource = (String)party1Value.metaDataMap.get(srcField);
		String party2ValSource = (String)party2Value.metaDataMap.get(srcField);

		// split the source priority order and put in array
		String[] srcPriOrderArr = srcPriorityOrder.split(",");

		String[] fieldsAffectedArr = fieldsAffected.split(",");
		
		HashMap<String, Integer> srcPriOrderMap = new HashMap<String, Integer>();

		int counter = 99;

		// put the sources in a map and assign a priority to it
		for (String source : srcPriOrderArr) {
			counter--;
			srcPriOrderMap.put(source, counter);
		}

		// if source of val1 has a priority, and val2 does not (not in config), then add val2 to loser vector
		if(srcPriOrderMap.get(party1ValSource) != null && srcPriOrderMap.get(party2ValSource) == null){

			// do nothing val1 already has the surviving values
//			for (String fieldAffected : fieldsAffectedArr) {
//				party1Value.metaDataMap.put(fieldAffected, value)
//			}
//			party1Value
//			loserPartyVals.add(party2Value);

		}
		// if source of val2 does not have a priority (not in config), and val2 does then add val1 to loser vector
		else if(srcPriOrderMap.get(party1ValSource) == null && srcPriOrderMap.get(party2ValSource) != null){

			for (String fieldAffected : fieldsAffectedArr) {
			party1Value.metaDataMap.put(fieldAffected, party2Value.metaDataMap.get(fieldAffected));
			}
//			loserPartyVals.add(party1Value);

		}
		// if source of val1 has a higher priority than source of val2, then put val2 in loser vector
		else if(srcPriOrderMap.get(party1ValSource) > srcPriOrderMap.get(party2ValSource)){

//			loserPartyVals.add(party2Value);

		}
		// if source of val2 has a higher priority than source of val1, then put val1 in loser vector
		else if(srcPriOrderMap.get(party2ValSource) > srcPriOrderMap.get(party1ValSource)){

			for (String fieldAffected : fieldsAffectedArr) {
			party1Value.metaDataMap.put(fieldAffected, party2Value.metaDataMap.get(fieldAffected));
			}
//			loserPartyVals.add(party1Value);

		} else {
			// if source of val1 is equal to source of val2, or borth sources are not in the priority list,
			// then pick the non-surviving object as the one having the older last update date and then put
			// it into the loser vector
			String party1LastUpdDateStr = (String)party1Value.metaDataMap.get(lastUpdField);
			String party2LastUpdDateStr = (String)party2Value.metaDataMap.get(lastUpdField);
			Date party1ValueLastUpd = null;
			Date party2ValueLastUpd = null;

			// if the val1 has an last update date string, set it as a date object
			if(party1LastUpdDateStr != null && !party1LastUpdDateStr.equals("")){
				party1ValueLastUpd = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.S").parse(party1LastUpdDateStr);
			}
			// if the val2 has an last update date string, set it as a date object
			if(party2LastUpdDateStr != null && !party2LastUpdDateStr.equals("")){
				party2ValueLastUpd = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.S").parse(party2LastUpdDateStr);
			}

			// if val1 and val2 both have last update dates, put the older last update date into the loser vector
			// if they happen to have the same last update date, just put the second last update date in the loser vector
			if(party1ValueLastUpd != null & party2ValueLastUpd != null && party1ValueLastUpd.after(party2ValueLastUpd)){
//				loserPartyVals.add(party2Value);
			} 
			else if(party1ValueLastUpd != null & party2ValueLastUpd != null && party2ValueLastUpd.after(party1ValueLastUpd)){
				for (String fieldAffected : fieldsAffectedArr) {
					party1Value.metaDataMap.put(fieldAffected, party2Value.metaDataMap.get(fieldAffected));
					}
				//				loserPartyVals.add(party1Value);
			} else{
				loserPartyVals.add(party2Value);
			}
		}

		// return non-survivors
//		return loserPartyVals;
	}

	/**
	 *This method collapses Party 1 and Party 2 address business objects.
	 *Address usage type is used as business keys to determine duplicates. Unique party address business
	 *objects from party 1 and Party 2 are survived. For duplicates the most recent address business object is survived.
	 * 
	 * @param vector sourcePartyAddressBObj
	 * @param vector targetPartyAddressBObj
	 * @param newOrgBobj
	 * @return  
	 * @throws Exception	 
	 */	 
	@SuppressWarnings("unchecked")
	public void mergePartyAddressBObj(boolean externallyCalled, Vector<XNWPartyAddressBObjExt> vecParty1Vals, Vector<XNWPartyAddressBObjExt> vecParty2Vals, TCRMPartyBObj newPartyBobj, ArrayList<String> rules) throws Exception
	{			 
		String srcField;
		String usageType;
		String lastUpdField;
		String srcPriorityOrder;
		String fieldsAffected;

		// parse the rule entries and store into a party rule ArrayList
		if(rules != null && rules.size() > 0){
			ArrayList<String[]> parsedRules = new ArrayList<String[]>();
			for (String rule : rules) {
				String[] partyRuleArr = rule.split("\\|");

				if(partyRuleArr.length != 5){
					throw new BusinessProxyException("In record collapse. Survivorship rule requires 5 settings. Found: " + partyRuleArr.length);
				} else{
					parsedRules.add(partyRuleArr);
				}
			}

			// compare rows from each party to each other using the rules in the party rules array
			for (XNWPartyAddressBObjExt party1Value : vecParty1Vals) {
				for (XNWPartyAddressBObjExt party2Value : vecParty2Vals) {

					for (String[] ruleArr : parsedRules) {

						// store rules in variables
						srcField = ruleArr[0];
						usageType = ruleArr[1];
						lastUpdField = ruleArr[2];
						srcPriorityOrder = ruleArr[3];
						fieldsAffected = ruleArr[4];

						// uniqueness is based on usage type and value combination
						if(party1Value.getAddressUsageValue().equals(party2Value.getAddressUsageValue())
								&& party1Value.getAddressUsageValue().equals(usageType)
								&&	StringUtils.compareWithTrim(party1Value.getTCRMAddressBObj().getAddressLineOne(), party2Value.getTCRMAddressBObj().getAddressLineOne())
								&&	StringUtils.compareWithTrim(party1Value.getTCRMAddressBObj().getAddressLineTwo(),party2Value.getTCRMAddressBObj().getAddressLineTwo())
								&&	StringUtils.compareWithTrim(party1Value.getTCRMAddressBObj().getCity(),party2Value.getTCRMAddressBObj().getCity())
								&&	StringUtils.compareWithTrim(party1Value.getTCRMAddressBObj().getProvinceStateValue(),party2Value.getTCRMAddressBObj().getProvinceStateValue())
								&&	StringUtils.compareWithTrim(party1Value.getTCRMAddressBObj().getZipPostalCode(),party2Value.getTCRMAddressBObj().getZipPostalCode())
								&&	StringUtils.compareWithTrim(((XNWAddressBObjExt)party1Value.getTCRMAddressBObj()).getXFacility_Code(), ((XNWAddressBObjExt)party2Value.getTCRMAddressBObj()).getXFacility_Code())
								&&	StringUtils.compareWithTrim(((XNWAddressBObjExt)party1Value.getTCRMAddressBObj()).getXDepartment_Code(), ((XNWAddressBObjExt)party2Value.getTCRMAddressBObj()).getXDepartment_Code())
								&&	StringUtils.compareWithTrim(((XNWAddressBObjExt)party1Value.getTCRMAddressBObj()).getXLocation_Code(), ((XNWAddressBObjExt)party2Value.getTCRMAddressBObj()).getXLocation_Code())
								&&	StringUtils.compareWithTrim(((XNWAddressBObjExt)party1Value.getTCRMAddressBObj()).getXFacility_Name(), ((XNWAddressBObjExt)party2Value.getTCRMAddressBObj()).getXFacility_Name())
								&&	StringUtils.compareWithTrim(((XNWAddressBObjExt)party1Value.getTCRMAddressBObj()).getXLocation_Name(), ((XNWAddressBObjExt)party2Value.getTCRMAddressBObj()).getXLocation_Name())
								){
							// the call below returns the *non-survivors*
							//loserPartyVals = (Vector<TCRMCommon>)
									applySurvivorship(srcField, lastUpdField, srcPriorityOrder, fieldsAffected, party1Value, party2Value, newPartyBobj);

						}
					}
				}
			}

//			// if called from within this class (execute method) combine all the attributes into the primary vector
//			if(!externallyCalled)
//				vecParty1Vals.addAll(vecParty2Vals);

//			// cast the loser objects to as appropriate object type
//			for (TCRMCommon loserPartyVal : loserPartyVals){
//				losersCasted.add((XNWPartyAddressBObjExt)loserPartyVal);
//			}

			// remove all loser objects from the primary vector. This leaves the survivors in the primary vector
//			vecParty1Vals.removeAll(losersCasted);
		}

		// if called from within this class (execute method), go thorugh each row in the 
		// primary vector and set the last upd and idpk to null
		if(!externallyCalled){
			for(int x=0; x< vecParty1Vals.size(); x++)
			{
				XNWPartyAddressBObjExt mergedBobj = (XNWPartyAddressBObjExt) vecParty1Vals.get(x);
//				if(updateFlag.equalsIgnoreCase("true")){
//					mergedBobj.setPartyId(objParty2BObj.getPartyId());
//				}
//				else{
					mergedBobj.setPartyAddressIdPK(null);
					mergedBobj.setPartyId(null);
					mergedBobj.setAddressId(null);
					mergedBobj.setAddressGroupLastUpdateDate(null);
					mergedBobj.setLocationGroupLastUpdateDate(null);
					mergedBobj.getTCRMAddressBObj().setAddressLastUpdateDate(null);		
					mergedBobj.getTCRMAddressBObj().setAddressIdPK(null);	
//				}
//				if(!newPartyBobj.getItemsTCRMPartyAddressBObj().contains(mergedBobj)){
//					newPartyBobj.getItemsTCRMPartyAddressBObj().add(mergedBobj);
//				}
			}
		}

		// clear the existing attribute objects from the party and add the primary vector objects to the party
		//		newPartyBobj.getItemsTCRMPartyAddressBObj().clear();
		//		newPartyBobj.getItemsTCRMPartyAddressBObj().addAll(vecParty1Vals);

		// in case where the method is called from outside this class (MaintainNWPersonCompositeTxnBP.java for example), return the *non-surviving* objects)
//		return losersCasted;
	}

	/**
	 * This method collapses Party1 and Party2 contact method business objects.
	 * Party Contact method usage type and contact method type is used as business keys to determine duplicates.
	 * Unique party contact method business objects from Party1 and Party2 are survived.
	 * For duplicates the most recent contact method business object is survived.
	 * 
	 * @param vector vecParty1ContMeth
	 * @param vector vecParty2ContMeth
	 * @param newPartyBobj
	 * @param partyNameRules 
	 * @return  
	 * @throws Exception	 
	 */		 
	public void mergePartyContactMethodBObj(boolean externallyCalled, Vector <TCRMPartyContactMethodBObj> vecParty1Vals, Vector <TCRMPartyContactMethodBObj> vecParty2Vals, TCRMPartyBObj newPartyBobj, ArrayList<String> rules) throws Exception
	{			 
		String srcField;
		String usageType;
		String lastUpdField;
		String srcPriorityOrder;
		String fieldsAffected;
		Vector<TCRMCommon> loserPartyVals = new Vector<TCRMCommon>();
		Vector<TCRMPartyContactMethodBObj> losersCasted = new Vector<TCRMPartyContactMethodBObj>();

		// parse the rule entries and store into a party rule ArrayList
		if(rules != null && rules.size() > 0){
			ArrayList<String[]> parsedRules = new ArrayList<String[]>();
			for (String rule : rules) {
				String[] partyRuleArr = rule.split("\\|");

				if(partyRuleArr.length != 5){
					throw new BusinessProxyException("In record collapse. Survivorship rule requires 5 settings. Found: " + partyRuleArr.length);
				} else{
					parsedRules.add(partyRuleArr);
				}
			}

			// compare rows from each party to each other using the rules in the party rules array
			for (TCRMPartyContactMethodBObj party1Value : vecParty1Vals) {
				for (TCRMPartyContactMethodBObj party2Value : vecParty2Vals) {

					for (String[] ruleArr : parsedRules) {

						// store rules in variables
						srcField = ruleArr[0];
						usageType = ruleArr[1];
						lastUpdField = ruleArr[2];
						srcPriorityOrder = ruleArr[3];
						fieldsAffected = ruleArr[4];
						
						// uniqueness is based on usage type only
						if(party1Value.getContactMethodUsageValue().equals(party2Value.getContactMethodUsageValue())
								&& party1Value.getContactMethodUsageValue().equals(usageType)){
							// the call below returns the *non-survivors*
							applySurvivorship(srcField, lastUpdField, srcPriorityOrder, fieldsAffected, party1Value, party2Value, newPartyBobj);

						}
					}
				}
			}

//			// if called from within this class (execute method) combine all the attributes into the primary vector
//			if(!externallyCalled)
//				vecParty1Vals.addAll(vecParty2Vals);
//
//			// cast the loser objects to as appropriate object type
//			for (TCRMCommon loserPartyVal : loserPartyVals){
//				losersCasted.add((TCRMPartyContactMethodBObj)loserPartyVal);
//			}
//
//			// remove all loser objects from the primary vector. This leaves the survivors in the primary vector
//			vecParty1Vals.removeAll(losersCasted);

		}

		// if called from within this class (execute method), go thorugh each row in the 
		// primary vector and set the last upd and idpk to null
		if(!externallyCalled){
			for(int x=0; x< vecParty1Vals.size(); x++)
			{
				TCRMPartyContactMethodBObj mergedBobj = (TCRMPartyContactMethodBObj) vecParty1Vals.get(x);

//				if(updateFlag.equalsIgnoreCase("true")){
//					mergedBobj.setPartyId(objParty2BObj.getPartyId());
//				}
//				else{
					mergedBobj.setPartyId(null);
					mergedBobj.setPartyContactMethodIdPK(null);
					mergedBobj.getTCRMContactMethodBObj().setContactMethodIdPK(null);

					mergedBobj.setLocationGroupLastUpdateDate(null);
					mergedBobj.setContactMethodGroupLastUpdateDate(null);
					mergedBobj.getTCRMContactMethodBObj().setContactMethodLastUpdateDate(null);
					mergedBobj.setContactMethodId(null);
//				}

//				if(!newPartyBobj.getItemsTCRMPartyContactMethodBObj().contains(mergedBobj)){
//					newPartyBobj.getItemsTCRMPartyContactMethodBObj().add(mergedBobj);
//				}
			}

		}

		// clear the existing attribute objects from the party and add the primary vector objects to the party
		//		newPartyBobj.getItemsTCRMPartyContactMethodBObj().clear();
		//		newPartyBobj.getItemsTCRMPartyContactMethodBObj().addAll(vecParty1Vals);

		// in case where the method is called from outside this class (MaintainNWPersonCompositeTxnBP.java for example), return the *non-surviving* objects)
//		return losersCasted; 	
	}


	/**
	 * This method adds source and target suppliers AdminContEquiv business object to new supplier
	 * Note- Each record will have at least one Source ID associated
	 *  
	 * @param vector sourceAdminContEquivBObj
	 * @param vector targetAdminContEquivBObj
	 * @param newOrgBobj
	 * @return  
	 * @throws Exception	 
	 */	 		 
	private void mergeAdminContEquivBObj(Vector <TCRMAdminContEquivBObj> vecParty1AdminContEquiv, Vector <TCRMAdminContEquivBObj> vecParty2AdminContEquiv, TCRMPartyBObj newPartyBobj) throws Exception
	{		 
		Vector <TCRMAdminContEquivBObj> vecMergedAdminContEquiv = new Vector();

		vecMergedAdminContEquiv.addAll(vecParty1AdminContEquiv);
		vecMergedAdminContEquiv.addAll(vecParty2AdminContEquiv);

		for(int i=0; i < vecMergedAdminContEquiv.size(); i++)
		{
			TCRMAdminContEquivBObj mergedAdminContEquivBobj = vecMergedAdminContEquiv.get(i);

//			if(updateFlag.equalsIgnoreCase("true")){
//				mergedAdminContEquivBobj.setPartyId(objParty2BObj.getPartyId());
//			}
//			else{
				mergedAdminContEquivBobj.setPartyId(null);
				mergedAdminContEquivBobj.setAdminContEquivIdPK(null);
				mergedAdminContEquivBobj.setContEquivLastUpdateDate(null);
//			}

			if(!newPartyBobj.getItemsTCRMAdminContEquivBObj().contains(mergedAdminContEquivBobj))
				newPartyBobj.setTCRMAdminContEquivBObj(mergedAdminContEquivBobj);
		}		 		 
	}	 


	/**
	 *This method collapses Party 1 and Party 2 person name business objects.
	 *Name usage type is used as business keys to determine duplicates.
	 *For duplicates the most recent address business object is survived.
	 * 
	 * @param vector vecParty1Name
	 * @param vector vecParty2Name
	 * @param newPersonBObj
	 * @param personNameRules 
	 * @return  
	 * @throws Exception	 
	 */	 
	public void mergePersonNameBObj(boolean externallyCalled, Vector <XNWPersonNameBObjExt> vecParty1Vals, Vector <XNWPersonNameBObjExt> vecParty2Vals, TCRMPartyBObj newPartyBobj, ArrayList<String> rules) throws Exception
	{			 
		String srcField;
		String usageType;
		String lastUpdField;
		String srcPriorityOrder;
		String fieldsAffected;
		Vector<TCRMCommon> loserPartyVals = new Vector<TCRMCommon>();
		Vector<XNWPersonNameBObjExt> losersCasted = new Vector<XNWPersonNameBObjExt>();

		// parse the rule entries and store into a party rule ArrayList
		if(rules != null && rules.size() > 0){
			ArrayList<String[]> parsedRules = new ArrayList<String[]>();
			for (String rule : rules) {
				String[] partyRuleArr = rule.split("\\|");

				if(partyRuleArr.length != 5){
					throw new BusinessProxyException("In record collapse. Survivorship rule requires 5 settings. Found: " + partyRuleArr.length);
				} else{
					parsedRules.add(partyRuleArr);
				}
			}

			// compare rows from each party to each other using the rules in the party rules array
			for (XNWPersonNameBObjExt party1Value : vecParty1Vals) {
				for (XNWPersonNameBObjExt party2Value : vecParty2Vals) {

					for (String[] ruleArr : parsedRules) {

						// store rules in variables
						srcField = ruleArr[0];
						usageType = ruleArr[1];
						lastUpdField = ruleArr[2];
						srcPriorityOrder = ruleArr[3];
						fieldsAffected = ruleArr[4];
						
						// uniqueness is based on usage type only, except for multi-value names which are based on usage type + value combination
						if(party1Value.getNameUsageValue().equals(party2Value.getNameUsageValue())
								&& party1Value.getNameUsageValue().equals(usageType)
								&& (!multiValueNames.contains(party1Value.getNameUsageValue()) || 
										(multiValueNames.contains(party1Value.getNameUsageValue())
												&& StringUtils.compareWithTrim(party1Value.getGivenNameOne(), party2Value.getGivenNameOne()) 
												&& StringUtils.compareWithTrim(party1Value.getLastName(), party2Value.getLastName()) 
												&& (StringUtils.compareWithTrim(party1Value.getGivenNameTwo(), party2Value.getGivenNameTwo()) || 
														(party1Value.getGivenNameTwo() == null && party2Value.getGivenNameTwo() != null) || 
														(party1Value.getGivenNameTwo() != null && party2Value.getGivenNameTwo() == null)
														)
												)
										)
								){
							// the call below returns the *non-survivors*
							applySurvivorship(srcField, lastUpdField, srcPriorityOrder, fieldsAffected, party1Value, party2Value, newPartyBobj);

						}
					}
				}
			}

//			// if called from within this class (execute method) combine all the attributes into the primary vector
//			if(!externallyCalled)
//				vecParty1Vals.addAll(vecParty2Vals);
//
//			// cast the loser objects to as appropriate object type
//			for (TCRMCommon loserPartyVal : loserPartyVals){
//				losersCasted.add((XNWPersonNameBObjExt)loserPartyVal);
//			}
//
//			// remove all loser objects from the primary vector. This leaves the survivors in the primary vector
//			vecParty1Vals.removeAll(losersCasted);
		}

		// if called from within this class (execute method), go thorugh each row in the 
		// primary vector and set the last upd and idpk to null
		if(!externallyCalled){
			for(int x=0; x< vecParty1Vals.size(); x++)
			{
				XNWPersonNameBObjExt mergedBobj = (XNWPersonNameBObjExt) vecParty1Vals.get(x);

//				if(updateFlag.equalsIgnoreCase("true")){
//					mergedBobj.setContId(objParty2BObj.getPartyId());
//				}
//				else{
					mergedBobj.setContId(null);
					mergedBobj.setLastUpdatedDate(null);
					mergedBobj.setPersonNameIdPK(null);
//				}

//				if(!((XNWPersonBObjExt)newPartyBobj).getItemsTCRMPersonNameBObj().contains(mergedBobj)){
//					((XNWPersonBObjExt)newPartyBobj).getItemsTCRMPersonNameBObj().add(mergedBobj);
//				}
			}
		}

		// clear the existing attribute objects from the party and add the primary vector objects to the party
		//		((XNWPersonBObjExt)newPartyBobj).getItemsTCRMPersonNameBObj().clear();
		//		((XNWPersonBObjExt)newPartyBobj).getItemsTCRMPersonNameBObj().addAll(vecParty1Vals);

		// in case where the method is called from outside this class (MaintainNWPersonCompositeTxnBP.java for example), return the *non-surviving* objects)
//		return losersCasted; 	
	}

	/**
	 * This method collapses Party 1 and Party 2 person business objects
	 * @param personRules 
	 * 
	 * @param vector sourcePartyIdentificationBObj
	 * @param vector targetPartyIdentificationBObj
	 * @param newOrgBobj
	 * @return  
	 * @throws Exception	 
	 */		
	public XNWPersonBObjExt mergePersonBObj(XNWPersonBObjExt party1PersonBObj, XNWPersonBObjExt party2PersonBObj, XNWPersonBObjExt newPersonBObj, ArrayList<String> personRules) throws Exception
	{
		String srcField;
		String lastUpdField;
		String srcPriorityOrder;
		String fieldsAffected;

		// parse the rule entries and store into a party rule ArrayList
		if(personRules != null && personRules.size() > 0){

			ArrayList<String[]> parsedPersonRules = new ArrayList<String[]>();

			for (String personRule : personRules) {
				String[] personRuleArr = personRule.split("\\|");

				if(personRuleArr.length != 5){
					throw new BusinessProxyException("In record collapse. Survivorship rule requires 5 settings. Found: " + personRuleArr.length);
				} else{
					parsedPersonRules.add(personRuleArr);
				}
			}

			// for each rule, set the field value on the newPersonObject depending on the result of the rule
			for (String[] personRuleArr : parsedPersonRules) {

				// store rule elements in variables
				srcField = personRuleArr[0];
				lastUpdField = personRuleArr[2];
				srcPriorityOrder = personRuleArr[3];
				fieldsAffected = personRuleArr[4];

				// get sources of each persons
				String party1Source = (String)party1PersonBObj.metaDataMap.get(srcField);
				String party2Source = (String)party2PersonBObj.metaDataMap.get(srcField);

				// spilt the source priorities into an array
				String[] srcPriOrderArr = srcPriorityOrder.split(",");

				HashMap<String, Integer> srcPriOrderMap = new HashMap<String, Integer>();

				// store the sources and the priorities into a map
				int counter = 99;
				for (String source : srcPriOrderArr) {
					counter--;
					srcPriOrderMap.put(source, counter);
				}

				// if party1 source is in priority list, but party2 source is not, then select the person1 value to put in newPersonBObj object
				if(srcPriOrderMap.get(party1Source) != null && srcPriOrderMap.get(party2Source) == null){
					for (String field : fieldsAffected.split(",")) {
//						newPersonBObj.metaDataMap.put(field, party1PersonBObj.metaDataMap.get(field));
					}
				}
				// if party1 source is not in priority list, but party2 source is, then select the person2 value to put in newPersonBObj object
				else if(srcPriOrderMap.get(party1Source) == null && srcPriOrderMap.get(party2Source) != null){
					for (String field : fieldsAffected.split(",")) {
						newPersonBObj.metaDataMap.put(field, party2PersonBObj.metaDataMap.get(field));
					}
				}
				// if party1 source is higher priority than party2 source is, then select the person1 value to put in newPersonBObj object
				else if(srcPriOrderMap.get(party1Source) > srcPriOrderMap.get(party2Source)){
					for (String field : fieldsAffected.split(",")) {
//						newPersonBObj.metaDataMap.put(field, party1PersonBObj.metaDataMap.get(field));
					}
				}
				// if party2 source is higher priority than party1 source is, then select the person2 value to put in newPersonBObj object
				else if(srcPriOrderMap.get(party2Source) > srcPriOrderMap.get(party1Source)){
					for (String field : fieldsAffected.split(",")) {
						newPersonBObj.metaDataMap.put(field, party2PersonBObj.metaDataMap.get(field));
					}
				} else {
					// if party1 source is equal priority than party2 source is (or both are not in the priority list)
					// then select the value that is most recent to put in newPersonBObj object

					Date party1PersonBObjLastUpd = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.S").parse((String)party1PersonBObj.metaDataMap.get(lastUpdField));
					Date party2PersonBObjLastUpd = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.S").parse((String)party2PersonBObj.metaDataMap.get(lastUpdField));

					if(party1PersonBObjLastUpd.after(party2PersonBObjLastUpd)){
						for (String field : fieldsAffected.split(",")) {
//							newPersonBObj.metaDataMap.put(field, party1PersonBObj.metaDataMap.get(field));
						}
					} else{
						for (String field : fieldsAffected.split(",")) {
							newPersonBObj.metaDataMap.put(field, party2PersonBObj.metaDataMap.get(field));
						}
					}
				}
			}
		}
		else {
			// if there were no rules for person, just select the first person object to survive
			newPersonBObj = party1PersonBObj;
		}

		// set the person1 control as the newPersonBObj control 
		newPersonBObj.setControl(party1PersonBObj.getControl());

		// return the newPersonBObj object representing a new person object containing the surviving person data
		return newPersonBObj;
	}

	// helper function to return status object if call returned an error
	protected DWLStatus addError(DWLControl theControl, String sErrorCode,
			String sReasonCode, String sDetail) {
		IDWLErrorMessage errHandler = TCRMClassFactory.getErrorHandler();

		DWLError error = errHandler.getErrorMessage(
				TCRMCoreComponentID.PARTY_COMPONENT, sErrorCode, sReasonCode,
				theControl, new String[0]);

		error.setDetail(sDetail);
		DWLStatus status = new DWLStatus();
		status.addError(error);
		status.setStatus(DWLStatus.FATAL);
		return status;
	}	 

	/*
	 * Get the survivorship rule configs from the MDM configuration
	 */
	@SuppressWarnings("unchecked")
	public void setSurvivorshipConfigs(DWLControl objDWLControl) throws ConfigurationRepositoryException, ManagementException, BusinessProxyException, DWLPropertyNotFoundException {

		// go through all of the survivorship configs for the object type and store them in an ArrayList
		ArrayList<String> partyIdentificationRules = new ArrayList<String>();
		for(int x = 0; x < 15; x++){

			String partyIdentificationRule = null;

			if(CommonUtil.isConfigOptionPresent("Survivorship/TCRMPartyIdentificationBObj/"+x))
				partyIdentificationRule = Configuration.getConfiguration()
				.getConfigItem("Survivorship/TCRMPartyIdentificationBObj/"+x, objDWLControl.retrieveConfigContext())
				.getValue();

			if(partyIdentificationRule != null){
				partyIdentificationRules.add(partyIdentificationRule);
			}
		}

		// also put the rules for the object type in the DWLControl object (for outside reference/storage)
		objDWLControl.put("Survivorship/TCRMPartyIdentificationBObj/", partyIdentificationRules);

		// go through all of the survivorship configs for the object type and store them in an ArrayList
		ArrayList<String> personNameRules = new ArrayList<String>();
		for(int x = 0; x < 15; x++){

			String personNameRule = null;

			if(CommonUtil.isConfigOptionPresent("Survivorship/XNWPersonNameBObjExt/"+x))
				personNameRule = Configuration.getConfiguration()
				.getConfigItem("Survivorship/XNWPersonNameBObjExt/"+x, objDWLControl.retrieveConfigContext())
				.getValue();

			if(personNameRule != null){
				personNameRules.add(personNameRule);
			}
		}

		// also put the rules for the object type in the DWLControl object (for outside reference/storage)
		objDWLControl.put("Survivorship/XNWPersonNameBObjExt/", personNameRules);

		// go through all of the survivorship configs for the object type and store them in an ArrayList
		ArrayList<String> partyAddressRules = new ArrayList<String>();
		for(int x = 0; x < 15; x++){

			String partyAddressRule = null;

			if(CommonUtil.isConfigOptionPresent("Survivorship/XNWPartyAddressBObjExt/"+x))
				partyAddressRule = Configuration.getConfiguration()
				.getConfigItem("Survivorship/XNWPartyAddressBObjExt/"+x, objDWLControl.retrieveConfigContext())
				.getValue();

			if(partyAddressRule != null){
				partyAddressRules.add(partyAddressRule);
			}
		}

		// also put the rules for the object type in the DWLControl object (for outside reference/storage)
		objDWLControl.put("Survivorship/XNWPartyAddressBObjExt/", partyAddressRules);

		// go through all of the survivorship configs for the object type and store them in an ArrayList
		ArrayList<String> partyValueRules = new ArrayList<String>();
		for(int x = 0; x < 15; x++){

			String partyValueRule = null;

			if(CommonUtil.isConfigOptionPresent("Survivorship/TCRMPartyValueBObj/"+x))
				partyValueRule = Configuration.getConfiguration()
				.getConfigItem("Survivorship/TCRMPartyValueBObj/"+x, objDWLControl.retrieveConfigContext())
				.getValue();

			if(partyValueRule != null){
				partyValueRules.add(partyValueRule);
			}
		}

		// also put the rules for the object type in the DWLControl object (for outside reference/storage)
		objDWLControl.put("Survivorship/TCRMPartyValueBObj/", partyValueRules);

		// go through all of the survivorship configs for the object type and store them in an ArrayList
		ArrayList<String> partyContactMethodRules = new ArrayList<String>();
		for(int x = 0; x < 15; x++){

			String partyContactMethodRule = null;

			if(CommonUtil.isConfigOptionPresent("Survivorship/TCRMPartyContactMethodBObj/"+x))
				partyContactMethodRule = Configuration.getConfiguration()
				.getConfigItem("Survivorship/TCRMPartyContactMethodBObj/"+x, objDWLControl.retrieveConfigContext())
				.getValue();

			if(partyContactMethodRule != null){
				partyContactMethodRules.add(partyContactMethodRule);
			}
		}

		// also put the rules for the object type in the DWLControl object (for outside reference/storage)
		objDWLControl.put("Survivorship/TCRMPartyContactMethodBObj/", partyContactMethodRules);

		// go through all of the survivorship configs for the object type and store them in an ArrayList
		ArrayList<String> personRules = new ArrayList<String>();
		for(int x = 0; x < 15; x++){

			String personRule = null;

			if(CommonUtil.isConfigOptionPresent("Survivorship/XNWPersonBObjExt/"+x))
				personRule = Configuration.getConfiguration()
				.getConfigItem("Survivorship/XNWPersonBObjExt/"+x, objDWLControl.retrieveConfigContext())
				.getValue();

			if(personRule != null){
				personRules.add(personRule);
			}
		}

		// also put the rules for the object type in the DWLControl object (for outside reference/storage)
		objDWLControl.put("Survivorship/XNWPersonBObjExt/", personRules);

		// also set SurvivorshipRulesSet key to "true" to signify that the survivorship configs have been retrieved and set 
		objDWLControl.put("SurvivorshipRulesSet", "true");
	}
}
